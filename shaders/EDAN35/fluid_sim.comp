#version 430

layout (local_size_x = 128, local_size_y = 1, local_size_z = 1) in;

// Uniforms

uniform int particles_nb;
uniform float deltaTime;
uniform float gravity;
uniform float collision_damping;
uniform float target_density;
uniform float influence_radius;
uniform float pressure_multiplier;
uniform float near_pressure_multiplier;

uniform float min_x;
uniform float max_x;
uniform float min_y;
uniform float max_y;
uniform float min_z;
uniform float max_z;

// Constants

const float mass = 1.0f;
const float PI = 3.14159;

struct Particle {
	vec3 position;
	vec3 predicted_position;
	vec3 velocity;
	float density;
	float near_density;
	float pad2;
	float pad3;
};

float smoothingKernel(float radius, float dist);
float smoothingKernelDerivative(float radius, float dist);
float nearDensityKernel(float radius, float dist);
float nearDensityKernelDerivative(float radius, float dist);

float calculateDensity(vec3 sample_point);
float calculateNearDensity(vec3 sample_point);

vec3 calculatePressureForce(int i);
vec3 calculateNearPressureForce(int i);

float calculateSharedPressure(float densityA, float densityB);
float convertDensityToPressure(float density);
float convertNearDensityToNearPressure(float near_density);

vec3 randomDirection();

layout(std430, binding = 5) buffer SSBO {
	Particle particles[];
};

void resolveCollisions() {
	uint i = gl_GlobalInvocationID.x;

	if (particles[i].position.x < min_x) {
		particles[i].position.x = min_x;
		particles[i].velocity.x *= -1 * collision_damping;
	} else if (particles[i].position.x > max_x) {
		particles[i].position.x = max_x;
		particles[i].velocity.x *= -1 * collision_damping;
	};

	if (particles[i].position.y < min_y) {
		particles[i].position.y = min_y;
		particles[i].velocity.y *= -1 * collision_damping;
	} else if (particles[i].position.y > max_y) {
		particles[i].position.y = max_y;
		particles[i].velocity.y *= -1 * collision_damping;
	};

	if (particles[i].position.z < min_z) {
		particles[i].position.z = min_z;
		particles[i].velocity.z *= -1 * collision_damping;
	} else if (particles[i].position.z > max_z) {
		particles[i].position.z = max_z;
		particles[i].velocity.z *= -1 * collision_damping;
	};
};

float smoothingKernel(float radius, float dist) { //ok
	if (dist >= radius) {
		return 0;
	}
	float volume = 2 * PI * pow(radius, 5) / 15;
	float value = dist - radius;
	return value * value / volume;
}

float smoothingKernelDerivative(float radius, float dist) { //ok
	if (dist >= radius) {
		return 0;
	}
	float scale = 15 / (PI * pow(radius, 5));
	return (dist - radius) * scale;
}

float nearDensityKernel(float radius, float dist) {
	if (dist >= radius) {
		return 0;
	}
	float volume = PI * pow(radius, 6) / 15;
	float value = radius - dist;
	return value * value * value / volume;
}

float nearDensityKernelDerivative(float radius, float dist) {
	if (dist >= radius) {
		return 0;
	}
	float value = radius - dist;
	float scale = -45 / (PI * pow(radius, 6));
	return value * value * scale;
}

float calculateDensity(vec3 sample_point) {  //ok
	float density = 0;
	for (int i = 0; i < particles_nb; i++) {
		float dist = distance(particles[i].predicted_position, sample_point);
		float influence = smoothingKernel(influence_radius, dist);
		density += mass * influence;
	}
	return density;
}

float calculateNearDensity(vec3 sample_point) {
	float near_density = 0;
	for (int i = 0; i < particles_nb; i++) {
		float dist = distance(particles[i].predicted_position, sample_point);
		float influence = nearDensityKernel(influence_radius, dist);
		near_density += mass * influence;
	}
	return near_density;
}

vec3 calculatePressureForce(int i) { //ok
	vec3 pressure_force = vec3(0, 0, 0);
	for (int other = 0; other < particles_nb; other++) {
		if (other == i) {
			continue;
		}

		vec3 offset = particles[other].predicted_position - particles[i].predicted_position;
		float dist = length(offset);
		vec3 direction = dist == 0 ? randomDirection() : offset / dist;
		direction += 0.0001 * randomDirection();
		float slope = smoothingKernelDerivative(influence_radius, dist);
		float densityA = particles[i].density;
		float nearDensityA = particles[i].near_density;
		float densityB = particles[other].density;
		float nearDensityB = particles[other].near_density;
		float shared_pressure = calculateSharedPressure(densityA, densityB);
		float nearPressureA = convertNearDensityToNearPressure(nearDensityA);
		float nearPressureB = convertNearDensityToNearPressure(nearDensityB);
		float shared_near_pressure = (nearPressureA + nearPressureB) / 2;
		pressure_force += direction * slope * shared_pressure * mass / densityA;
		pressure_force += direction * nearDensityKernelDerivative(influence_radius, dist) * shared_near_pressure / densityA;
	}
	return pressure_force;
}

float calculateSharedPressure(float densityA, float densityB) { //ok
	float pressureA = convertDensityToPressure(densityA);
	float pressureB = convertDensityToPressure(densityB);
	return (pressureA + pressureB) / 2;
}

float convertDensityToPressure(float density) { //ok
	float density_error = density - target_density;
	return density_error * pressure_multiplier;
}

float convertNearDensityToNearPressure(float near_density) {
	return near_density * near_pressure_multiplier;
}

float hash(float x) {
    return fract(sin(x) * 43758.5453123);
}

vec3 randomDirection() { // ???
	float seed = float(gl_GlobalInvocationID.x) + deltaTime * 1000;
	vec3 v = vec3(hash(seed + 1), hash(seed + 2), hash(seed + 3)) * 2 - 1;
	return normalize(v);
}



// Executed once for each particle
void main() {
	int i = int(gl_GlobalInvocationID.x); // Since the local size in one-dimensional, we can get the unique invocation ID only from the x value
	if (i >= particles_nb) {
		return;
	}

	vec3 down = vec3(0, -1, 0);
	particles[i].velocity += gravity * down * deltaTime;
	particles[i].predicted_position = particles[i].position + particles[i].velocity / 20.0f;
	memoryBarrierBuffer();
	barrier();
	particles[i].density = calculateDensity(particles[i].predicted_position);
	particles[i].near_density = calculateNearDensity(particles[i].predicted_position);
	memoryBarrierBuffer();
	barrier();
	vec3 pressure_force = calculatePressureForce(i);
	vec3 pressure_acceleration = pressure_force / particles[i].density;
	particles[i].velocity += pressure_acceleration * deltaTime;
	memoryBarrierBuffer();
	barrier();
	particles[i].position += particles[i].velocity * deltaTime;
	resolveCollisions();
}
